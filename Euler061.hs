-- Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal
-- numbers are all figurate (polygonal) numbers and are generated by
-- the following formulae:

-- Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
-- Square   	 	P4,n=n^2	       	1, 4, 9, 16, 25, ...
-- Pentagonal	 	P5,n=n(3n-1)/2	 	1, 5, 12, 22, 35, ...
-- Hexagonal	 	P6,n=n(2n-1)	 	1, 6, 15, 28, 45, ...
-- Heptagonal	 	P7,n=n(5n-3)/2	 	1, 7, 18, 34, 55, ...
-- Octagonal	 	P8,n=n(3n-2)	 	1, 8, 21, 40, 65, ...

-- The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

-- The set is cyclic, in that the last two digits of each number is
-- the first two digits of the next number (including the last number
-- with the first).

-- Each polygonal type: triangle (P3,127=8128), square (P4,91=8281),
-- and pentagonal (P5,44=2882), is represented by a different number
-- in the set.

-- This is the only set of 4-digit numbers with this property.

-- Find the sum of the only ordered set of six cyclic 4-digit numbers
-- for which each polygonal type: triangle, square, pentagonal,
-- hexagonal, heptagonal, and octagonal, is represented by a different
-- number in the set.

module Euler061 where

import Data.List

polygonNum :: (Eq a, Integral b, Num a) => a -> b -> b
polygonNum 3 n = n * (n + 1) `div` 2
polygonNum 4 n = n ^ 2
polygonNum 5 n = n * (3 * n - 1) `div` 2
polygonNum 6 n = n * (2 * n - 1)
polygonNum 7 n = n * (5 * n - 3) `div` 2
polygonNum 8 n = n * (3 * n - 2)

get4DigitNumbers :: (Eq b, Integral a, Num b) => b -> [a]
get4DigitNumbers i = dropWhile (<=999) . takeWhile (<=9999) $ map (polygonNum i) [1..]

canConcat :: Integral a => a -> a -> Bool
canConcat m n = m `mod` 100 == n `div` 100

findCycles :: (Eq b, Integral t, Num b) => [b] -> [[t]]
findCycles [i1,i2,i3,i4,i5,i6] = [[a,b,c,d,e,f] |
                                  let la = get4DigitNumbers i1,
                                  a <- la,
                                  let lb = filter (canConcat a) $ get4DigitNumbers i2,
                                  b <- lb,
                                  let lc = filter (canConcat b) $ get4DigitNumbers i3,
                                  c <- lc,
                                  let ld = filter (canConcat c) $ get4DigitNumbers i4,
                                  d <- ld,
                                  let le = filter (canConcat d) $ get4DigitNumbers i5,
                                  e <- le,
                                  let lf = filter (canConcat e) $ get4DigitNumbers i6,
                                  f <- lf,
                                  canConcat f a]

result061 = sum . head . concatMap findCycles . map (3:) $ permutations [4..8]
